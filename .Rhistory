# Load necessary libraries
library(readr)
library(dplyr)
library(tidyr)
# Read the CSV file
setwd("~/Desktop/REPLICATION ASSIGNMENT/GROUP_ASSIGNMENT")
ceo_data <- read_csv("survey_response_data.csv")
# Set 'id' as the row identifier
ceo_data <- ceo_data %>%
filter(level1 == 'interacting',
type != 'personal_family',
id != 1115) %>%
mutate(id = as.character(id))
# Function to create crosstabs
create_crosstab <- function(data, row_var, col_var, value_filter = NULL) {
if (!is.null(value_filter)) {
data <- data %>% filter(!!sym(col_var) != value_filter)
}
data %>%
count(!!sym(row_var), !!sym(col_var)) %>%
pivot_wider(names_from = !!sym(col_var), values_from = n, values_fill = 0)
}
df1 <- create_crosstab(ceo_data, "id", "F_duration")
df2 <- create_crosstab(ceo_data, "id", "F_planned", value_filter = "missing")
df3 <- create_crosstab(ceo_data, "id", "F_participants", value_filter = "missing")
ceo_data <- ceo_data %>%
mutate(
ins_alone = ifelse(ins == 1.0 & out == 0.0, 1, 0),
out_alone = ifelse(ins == 0.0 & out == 1.0, 1, 0),
ins_out = ifelse(ins == 1.0 & out == 1.0, 1, 0),
coordinate = ifelse(n_functions > 1, 1, 0),
activity_dummy = 1
)
df5a <- create_crosstab(ceo_data, "id", "out")
df_groupcom <- create_crosstab(ceo_data, "id", "groupcom")
df_bunits <- create_crosstab(ceo_data, "id", "bunits")
df_coo <- create_crosstab(ceo_data, "id", "coo")
df_cao <- create_crosstab(ceo_data, "id", "cao")
df6 <- create_crosstab(ceo_data, "id", "coordinate")
# Rename columns before joining
df5a <- df5a %>%
rename(out = `1`) %>%
select(id, out)
df6 <- df6 %>%
rename(coordinate2 = `1`) %>%
select(id, coordinate2)
df_groupcom <- df_groupcom %>%
rename(groupcom = `1`) %>%
select(id, groupcom)
df_bunits <- df_bunits %>%
rename(bunits = `1`) %>%
select(id, bunits)
df_coo <- df_coo %>%
rename(coo = `1`) %>%
select(id, coo)
df_cao <- df_cao %>%
rename(cao = `1`) %>%
select(id, cao)
# Aggregate data
agg_data <- data.frame(id = df1$id) %>%
left_join(df1, by = "id") %>%
left_join(df2, by = "id") %>%
left_join(df3, by = "id") %>%
left_join(df5a, by = "id") %>%
left_join(df_groupcom, by = "id") %>%
left_join(df_bunits, by = "id") %>%
left_join(df_coo, by = "id") %>%
left_join(df_cao, by = "id") %>%
left_join(df6, by = "id") %>%
replace(is.na(.), 0)
# Rename and mutate to create the desired variables
agg_data <- agg_data %>%
rename(
long = `1hrplus`,
planned = planned,
large = `two_plus_ppl`
) %>%
mutate(
coordinate1 = groupcom + bunits + coo + cao
) %>%
select(id, long, planned, large, out, coordinate1, coordinate2)
# Verify the renamed and mutated agg_data
print("Renamed and Mutated agg_data:")
print(head(agg_data))
# Calculate activities by summing 'activity_dummy' for each 'id'
activities <- ceo_data %>%
group_by(id) %>%
summarise(activity_dummy = sum(activity_dummy, na.rm = TRUE))
# Verify the activities dataframe
print("Activities:")
print(head(activities))
str(activities)
# Merge activities with agg_data and calculate shares
agg_data_share <- agg_data %>%
left_join(activities, by = "id") %>%
mutate(
long = long / activity_dummy,
planned = planned / activity_dummy,
large = large / activity_dummy,
out = out / activity_dummy,
coordinate1 = coordinate1 / activity_dummy,
coordinate2 = coordinate2 / activity_dummy
) %>%
# Remove the 'activity_dummy' column as it's no longer needed
select(-activity_dummy)
# Verify the agg_data_share dataframe
print("Aggregated Data Share:")
print(head(agg_data_share))
str(agg_data_share)
# Remove 'id' column for PCA as it's an identifier, not a feature
pca_data <- agg_data_share %>%
select(-id)
# Verify the PCA data
print("PCA Data:")
print(head(pca_data))
str(pca_data)
# Compute the correlation matrix
cor_matrix <- cor(pca_data, use = "complete.obs")
# Perform eigen decomposition on the correlation matrix
eig <- eigen(cor_matrix)
eig_vals <- eig$values
eig_vecs <- eig$vectors
# Print eigenvalues to understand the variance captured by each component
print("Eigenvalues:")
print(eig_vals)
# Determine the number of principal components to retain
# For example, retain components with eigenvalues > 1 or based on cumulative variance
# Here, we'll select the top 2 components as per your original Python code
# Order eigenvalues in decreasing order and get the indices of the top 2
ordered_indices <- order(eig_vals, decreasing = TRUE)[1:2]
# Extract the corresponding eigenvectors (principal components)
pca_components <- eig_vecs[, ordered_indices]
# Project the data onto the first two principal components
pca_scores <- as.matrix(pca_data) %*% pca_components
# Verify PCA scores
print("PCA Scores (First 6 Rows):")
print(head(pca_scores*-1))
##K-MEANS
# Assuming 'agg_data' has been created as per previous steps
# Load necessary libraries
library(dplyr)
# Calculate the total count per CEO
agg_data$total_count <- rowSums(agg_data[, c('long', 'planned', 'large', 'out', 'coordinate1', 'coordinate2')])
#
#Calculate the shares
#agg_data_share <- agg_data %>%
# mutate(
#  long_share = long / total_count,
# planned_share = planned / total_count,
#large_share = large / total_count,
#out_share = out / total_count,
#coordinate1_share = coordinate1 / total_count,
#coordinate2_share = coordinate2 / total_count
#) %>%
#select(id, ends_with('_share'))
# Prepare the data for k-means (exclude 'id' column)
kmeans_data <- agg_data_share %>%
select(-id)
# Set seed for reproducibility
set.seed(60)
# Perform k-means clustering
num_clusters <- 2
kmeans_result <- kmeans(kmeans_data, centers = num_clusters, nstart = 1)
# Extract the centroids
centroids <- kmeans_result$centers
# Extract the cluster labels
labels <- kmeans_result$cluster
# Extract the total within-cluster sum of squares (inertia)
inertia <- kmeans_result$tot.withinss
# Display the results
print("K-Means centroids:")
print(centroids)
print("K-Means labels (first 10):")
print(labels[1:10])
print(paste("K-Means total within-cluster sum of squares (inertia):", inertia))
View(agg_data)
View(activities)
View(kmeans_result)
View(pca_components)
View(cor_matrix)
print("K-Means labels (first 10):")
print(labels[1:1100])
print(labels[1:1114])
getOption(("max.print")
options(max.print = 2000)
print("K-Means labels (first 10):")
print(labels)
print("K-Means centroids:")
print(centroids)
# Perform k-means clustering
num_clusters <- 3
kmeans_result <- kmeans(kmeans_data, centers = num_clusters, nstart = 1)
# Extract the centroids
centroids <- kmeans_result$centers
# Extract the cluster labels
labels <- kmeans_result$cluster
# Extract the total within-cluster sum of squares (inertia)
inertia <- kmeans_result$tot.withinss
# Display the results
print("K-Means centroids:")
print(centroids)
print("K-Means labels (first 10):")
print(labels)
print(paste("K-Means total within-cluster sum of squares (inertia):", inertia))
open("survey_response_data.csv")
browse
view
View(ceo_data)
head(ceo_data)
TABLE1
#TABLE1
# Sample column headers (from your example)
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
install.packages("knitr")
#TABLE1
# Sample column headers (from your example)
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
install.packages("kableExtra")
#TABLE1
# Sample column headers (from your example)
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
# Create and display a styled correlation matrix
kable(cor_matrix, format = "html", digits = 2) %>%
kable_styling(full_width = F, font_size = 12)
#TABLE1
# Sample column headers (from your example)
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
# Create and display a styled correlation matrix
kable(cor_matrix, format = "html", digits = 3) %>%
kable_styling(full_width = F, font_size = 12)
# List of variables used in the table
selected_vars <- c("Meeting", "Plant_visit", "Communications", "Planned",
">1_Participant", ">1_Function", "Insiders", "Outsiders",
"Insiders_and_Outsiders", "C_Suite", "Production",
"Marketing", "Clients", "Suppliers", "Consultants")
# Ensure variable names in your dataset match these exactly. Replace with underscores if needed.
# Subset the dataset to include only the relevant variables
subset_data <- ceo_data[selected_vars]
# List of variables used in the table
selected_vars <- c( ">1_Participant", ">1_Function", "Insiders", "Outsiders",
"Insiders_and_Outsiders", "C_Suite", "Production",
"Marketing", "Clients", "Suppliers", "Consultants")
# Ensure variable names in your dataset match these exactly. Replace with underscores if needed.
# Subset the dataset to include only the relevant variables
subset_data <- ceo_data[selected_vars]
# List of variables used in the table
selected_vars <- c("Production", "Marketing", "Clients", "Suppliers", "Consultants")
# Ensure variable names in your dataset match these exactly. Replace with underscores if needed.
# Subset the dataset to include only the relevant variables
subset_data <- ceo_data[selected_vars]
# List of variables used in the table
selected_vars <- c("meeting", "plant_visit", "communications", "planned",
">1_participant", ">1_function", "ins_alone", "out_alone",
"ins_out", "c_suite", "production",
"mkting", "clients", "suppliers", "consultants")
# Ensure variable names in your dataset match these exactly. Replace with underscores if needed.
# Subset the dataset to include only the relevant variables
subset_data <- ceo_data[selected_vars]
rlang::last_trace()
# List of variables used in the table
selected_vars <- c(
"mkting", "clients", "suppliers", "consultants")
# Ensure variable names in your dataset match these exactly. Replace with underscores if needed.
# Subset the dataset to include only the relevant variables
subset_data <- ceo_data[selected_vars]
# Compute the correlation matrix
cor_matrix <- cor(subset_data, use = "complete.obs") # Exclude NA values
# Display the correlation matrix using kableExtra for styling
library(knitr)
library(kableExtra)
kable(cor_matrix, format = "html", digits = 2) %>%
kable_styling(full_width = F, font_size = 12)
# Calculate the correlation between 'mkting' and 'consultants'
correlation <- cor(ceo_data$mkting, ceo_data$consultants, use = "complete.obs")
# Print the correlation
print(correlation)
#TABLE1
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
# Create and display a styled correlation matrix
kable(cor_matrix, format = "html", digits = 2) %>%
kable_styling(full_width = F, font_size = 12)
# Compute the correlation between 'mkting' and 'consultants', ignoring NA values for the pair
correlation <- cor(ceo_data$mkting, ceo_data$consultants, use = "pairwise.complete.obs")
# Print the result
print(correlation)
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
# Create and display a styled correlation matrix
kable(cor_matrix, format = "html", digits = 2) %>%
kable_styling(full_width = F, font_size = 12)
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
# Create and display a styled correlation matrix
kable(cor_matrix, format = "html", digits = 3) %>%
kable_styling(full_width = F, font_size = 12)
#TABLE1
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "pairwisecomplete.obs") # Exclude NA values
#TABLE1
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "pairwise.complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
# Create and display a styled correlation matrix
kable(cor_matrix, format = "html", digits = 2) %>%
kable_styling(full_width = F, font_size = 12)
# Install and load the corrr package
install.packages("corrr")
library(corrr)
# Select numeric columns and compute correlation
cor_matrix <- ceo_data %>%
select(where(is.numeric)) %>%
correlate()
# View the correlation matrix
print(cor_matrix)
print(n=40)
# Install and load the corrr package
install.packages("corrr")
library(corrr)
# Select numeric columns and compute correlation
cor_matrix <- ceo_data %>%
select(where(is.numeric)) %>%
correlate()
# View the correlation matrix
print(cor_matrix, n=40)
install.packages("corrr")
print("PCA Scores (First 6 Rows):")
print(head(pca_scores*-1))
# Assuming your dataset is already loaded and named ceo_data
# Select numeric columns for correlation analysis
numeric_columns <- ceo_data[sapply(ceo_data, is.numeric)]
# Compute the correlation matrix
cor_matrix <- cor(numeric_columns, use = "pairwise.complete.obs") # Exclude NA values
# Format and display the correlation matrix using kableExtra
library(knitr)
library(kableExtra)
# Create and display a styled correlation matrix
kable(cor_matrix, format = "html", digits = 2) %>%
kable_styling(full_width = F, font_size = 12)
install.packages("haven")  # For reading .dta files
install.packages("dplyr")  # For data manipulation
library(haven)
library(dplyr)
# Load the Stata file
corrdata <- read_dta("diegos_correlation_data.dta")
# View the structure of the dataset
str(data)
# Load the Stata file
corrdata <- read_dta("diegos_correlation_data.dta")
# View the structure of the dataset
str(data)
# Select specific variables for correlation analysis
selected_corrdata <- corrdata %>% select(mkting, suppliers, clients, consultants)
# Compute the correlation matrix
cor_matrix <- cor(selected_corrdata, use = "pairwise.complete.obs")  # Handles missing values pairwise
# Display the correlation matrix
print(cor_matrix)
view(corrdata)
View(ceo_data)
# Load the Stata file
corrdata <- read_dta("diegos_correlation_data.dta")
# Select specific variables for correlation analysis
selected_corrdata <- corrdata %>% select(mkting, suppliers, clients, consultants, F_planned
)
View(ceo_data)
View(corrdata)
corrdata <- read_dta("diegos_correlation_data.dta")
# Select specific variables for correlation analysis
selected_corrdata <- corrdata %>% select(mkting, suppliers, clients, consultants, dshaMeeting
)
# Compute the correlation matrix
cor_matrix <- cor(selected_corrdata, use = "pairwise.complete.obs")  # Handles missing values pairwise
# Display the correlation matrix
print(cor_matrix)
corrdata <- read_dta("diegos_correlation_data.dta")
# Select specific variables for correlation analysis
selected_corrdata <- corrdata %>% select(dshaMeeting, dshaSitevisit, planned, part_2more, hours_fumore1, ins, out, mix, top, production, mkting, clients, suppliers, consultants
)
# Compute the correlation matrix
cor_matrix <- cor(selected_corrdata, use = "pairwise.complete.obs")  # Handles missing values pairwise
# Display the correlation matrix
print(cor_matrix)
corrdata <- read_dta("diegos_correlation_data.dta")
# Select specific variables for correlation analysis
selected_corrdata <- corrdata %>% select(dshaMeeting, dshaSitevisit, dshaCommunications, planned, part_2more, hours_fumore1, ins, out, mix, top, production, mkting, clients, suppliers, consultants
)
# Compute the correlation matrix
cor_matrix <- cor(selected_corrdata, use = "pairwise.complete.obs")  # Handles missing values pairwise
# Display the correlation matrix
print(cor_matrix)
pca_result <- prcomp(agg_data_share, scale. = TRUE)
pca_values <- pca_result$x[, 1:2]  # Usar las dos primeras componentes principales
print(pca_components)
print(pca_components*-1)
print(head(pca_scores*-1))
print("K-Means labels (first 10):")
print(labels)
print(paste("K-Means total within-cluster sum of squares (inertia):", inertia))
set.seed(60)
# Perform k-means clustering
num_clusters <- 2
kmeans_result <- kmeans(kmeans_data, centers = num_clusters, nstart = 1)
# Extract the centroids
centroids <- kmeans_result$centers
# Extract the cluster labels
labels <- kmeans_result$cluster
# Extract the total within-cluster sum of squares (inertia)
inertia <- kmeans_result$tot.withinss
# Display the results
print("K-Means centroids:")
print(centroids)
print("K-Means labels (first 10):")
print(labels)
print(paste("K-Means total within-cluster sum of squares (inertia):", inertia))
library(lavaan)
install.packages("lavaan")
install.packages("psych")
library(lavaan)
library(psych)
install.packages(semTools)
efa
efa(ceo_data, nfactors = 3, rotation = "oblimin")
print("Eigenvalues:")
print(eig_vals)
